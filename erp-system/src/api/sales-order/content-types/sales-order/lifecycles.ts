import type { Core } from '@strapi/strapi';

export default {
  async beforeCreate(event: any) {
    const { data } = event.params;
    const { strapi }: { strapi: Core.Strapi } = event.state;

    // Auto-generate order number if not provided
    if (!data.order_number) {
      const count = await strapi.entityService.count('api::sales-order.sales-order');
      data.order_number = `SO-${String(count + 1).padStart(6, '0')}`;
    }
  },

  async afterCreate(event: any) {
    const { result } = event;
    const { strapi }: { strapi: Core.Strapi } = event.state;

    // Recalculate stock or reserve items (placeholder)
    console.log(`ðŸ“¦ Sales Order ${result.order_number} created - Stock reservation logic would go here`);
    
    // TODO: Implement stock reservation logic
    // const orderItems = await strapi.entityService.findMany('api::sales-order-item.sales-order-item', {
    //   filters: { sales_order: result.id },
    //   populate: { product: true }
    // });
    // 
    // for (const item of orderItems) {
    //   // Reserve stock logic here
    // }
  },

  async beforeUpdate(event: any) {
    const { data, where } = event.params;
    const { strapi }: { strapi: Core.Strapi } = event.state;

    // Prevent status change to "shipped" if items not in stock
    if (data.order_status === 'shipped') {
      const orderItems = await strapi.entityService.findMany('api::sales-order-item.sales-order-item', {
        filters: { sales_order: where.id },
        populate: { product: true }
      });

      for (const item of orderItems as any[]) {
        if (item.product && item.quantity > item.product.stock_quantity) {
          throw new Error(`Cannot ship order: Product ${item.product.name} has insufficient stock (${item.product.stock_quantity} available, ${item.quantity} required)`);
        }
      }
    }
  },

  async afterUpdate(event: any) {
    const { result } = event;
    const { strapi }: { strapi: Core.Strapi } = event.state;

    // If status becomes "confirmed", generate invoice
    if (result.order_status === 'confirmed') {
      try {
        const salesOrder = await strapi.entityService.findOne('api::sales-order.sales-order', result.id, {
          populate: { customer: { fields: ['id'] } }
        }) as any;

        // Calculate total amount from order items
        const orderItems = await strapi.entityService.findMany('api::sales-order-item.sales-order-item', {
          filters: { sales_order: { id: result.id } },
          fields: ['subtotal']
        });

        const totalAmount = orderItems.reduce((sum: number, item: any) => sum + (item.subtotal || 0), 0);

        // Create invoice (invoice_number will be auto-generated by invoice beforeCreate hook)
        const invoiceCount = await strapi.entityService.count('api::invoice.invoice');
        const tempInvoiceNumber = `INV-${String(invoiceCount + 1).padStart(6, '0')}`;
        
        const invoice = await strapi.entityService.create('api::invoice.invoice', {
          data: {
            invoice_number: tempInvoiceNumber,
            customer: salesOrder.customer?.id,
            sales_order: result.id,
            amount: totalAmount,
            issued_date: new Date(),
            due_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
            invoice_status: 'draft',
            notes: `Auto-generated from Sales Order ${result.order_number}`,
            publishedAt: new Date()
          }
        }) as any;

        console.log(`ðŸ“„ Invoice ${invoice.invoice_number} auto-generated for Sales Order ${result.order_number}`);
      } catch (error) {
        console.error('Failed to generate invoice for sales order:', error);
      }
    }
  }
};
